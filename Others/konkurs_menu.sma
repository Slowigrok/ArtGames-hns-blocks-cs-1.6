/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <cstrike>
#include <engine>
#include <fun>
#include <hamsandwich>

#define PLUGIN "New_plugin"
#define VERSION "1.0"
#define AUTHOR "slavok1717"
#define PREFIX "^03[^04Konkurs-menu^03]"

new bool:g_has_checkpoint[33];
new bool:g_checkpoint_duck[33];
new Float:g_checkpoint_position[33][3];

public plugin_init() 
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	register_clcmd("say /go_menu", "k_menu")
	register_clcmd("say_team /go_menu", "k_menu")
	
	//Create Menus
	new menu = register_menuid("MainMenu");
	register_menucmd(menu, 1023, "h_k_menu");
}

public k_menu(id)
{
	new szBuffer[512], iLen;
	
	iLen = formatex(szBuffer, sizeof szBuffer - 1, "\rServer Menu^n^n");
	iLen += formatex(szBuffer[iLen], (sizeof szBuffer - 1) - iLen, "\r1. \wRespawn^n");
	iLen += formatex(szBuffer[iLen], (sizeof szBuffer - 1) - iLen, "\r2. \wSave Checkpoint^n");
	iLen += formatex(szBuffer[iLen], (sizeof szBuffer - 1) - iLen, "\r3. \wLoad Checkpoint^n^n");
	iLen += formatex(szBuffer[iLen], (sizeof szBuffer - 1) - iLen, "\r4. \ySet Godmode^n^n");
	iLen += formatex(szBuffer[iLen], (sizeof szBuffer - 1) - iLen, "\r5. \wClose Menu");
	
	new iKeys = ( 1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4);
	
	show_menu(id, iKeys, szBuffer, -1, "MainMenu");
	
	return PLUGIN_HANDLED;
}

public h_k_menu(id, key)
{
	switch(key)
	{
		case 0:
		{
			CmdReviveYourself(id)
		}
		case 1:
		{
			CmdSaveCheckpoint(id)
		}
		case 2:
		{
			CmdLoadCheckpoint(id)
		}
		case 3:
		{
			set_user_godmode(id, 1);
			client_print(id, print_chat, "Success!");
			k_menu(id);
		}
		case 4:
		{
			return PLUGIN_HANDLED;
		}
	}
	
	return PLUGIN_HANDLED;
}

public CmdSaveCheckpoint(id)
{
	if ( !is_user_alive(id) )
	{
		Print(id, "You have to be alive to save a checkpoint!");
		return PLUGIN_HANDLED;
	}
	
	static Float:velocity[3];
	get_user_velocity(id, velocity);
	
	new button =	entity_get_int(id, EV_INT_button);
	new flags =	entity_get_int(id, EV_INT_flags);
	
	if ( !( ( velocity[2] >= 0.0 || ( flags & FL_INWATER ) ) && !( button & IN_JUMP ) && velocity[2] <= 0.0 ) )
	{
		Print(id, "You can't save a checkpoint while moving up or down!");
		return PLUGIN_HANDLED;
	}
	
	if ( flags & FL_DUCKING )	g_checkpoint_duck[id] = true;
	else				g_checkpoint_duck[id] = false;
	
	entity_get_vector(id, EV_VEC_origin, g_checkpoint_position[id]);
	
	Print(id, "Checkpoint saved!");
	
	if ( !g_has_checkpoint[id] )		g_has_checkpoint[id] = true;
	
	k_menu(id);
	
	return PLUGIN_HANDLED;
}

public CmdLoadCheckpoint(id)
{
	if ( !is_user_alive(id))
	{
		Print(id, "You have to be alive to load a checkpoint!");
		return PLUGIN_HANDLED;
	}
	else if ( !g_has_checkpoint[id] )
	{
		Print(id, "You don't have a checkpoint!");
		return PLUGIN_HANDLED;
	}
	
	static Float:origin[3];
	for ( new i = 1; i <= get_maxplayers(); i++ )
	{
		if ( i == id || !is_user_alive(id) ) continue;
		
		entity_get_vector(id, EV_VEC_origin, origin);
		
		if ( get_distance_f(g_checkpoint_position[id], origin) <= 35.0 )
		{
			if ( cs_get_user_team(i) == cs_get_user_team(id) ) continue;
			
			Print(id, "Somebody is too close to your checkpoint!");
			return PLUGIN_HANDLED;
		}
	}
	
	entity_set_vector(id, EV_VEC_origin, g_checkpoint_position[id]);
	entity_set_vector(id, EV_VEC_velocity, Float:{ 0.0, 0.0, 0.0 });
	
	if ( g_checkpoint_duck[id] )
	{
		entity_set_int(id, EV_INT_flags, entity_get_int(id, EV_INT_flags) | FL_DUCKING);
	}
	
	k_menu(id);
	
	return PLUGIN_HANDLED;
}

public CmdReviveYourself(id)
{
	if ( is_user_alive(id) )
	{
		Print(id, "You are already alive!");
		return PLUGIN_HANDLED;
	}
	
	ExecuteHam(Ham_CS_RoundRespawn, id);
	Print(id, "You have revived yourself!");
	
	static name[32];
	get_user_name(id, name, charsmax(name));
	
	for ( new i = 1; i <= get_maxplayers(); i++ )
	{
		if ( !is_user_connecting(i) || i == id ) continue;
		
		Print(i, "^1%s^3 revived himself!", name);
	}
	
	k_menu(id);
	
	return PLUGIN_HANDLED;
}

Print(iPlayer, const sMsg[], any:...) 
{
	static i; i = iPlayer ? iPlayer : get_Player();
	if ( !i ) return;
	
	new sMessage[256];
	new len = formatex(sMessage, sizeof(sMessage) - 1, "^x04%s ", PREFIX);
	vformat(sMessage[len], sizeof(sMessage) - 1 - len, sMsg, 3);
	sMessage[192] = '^0';
		
	if(is_user_connected(iPlayer))
	{
		static msgid_SayText;
		if ( !msgid_SayText ) msgid_SayText = get_user_msgid("SayText");
	
		new const team_Names[][] =
		{
			"",
			"TERRORIST",
			"CT",
			"SPECTATOR"
		};
		
		new sTeam = get_user_team(i);
	
		team_Info(i, iPlayer, team_Names[0]);
		
		message_begin(iPlayer ? MSG_ONE_UNRELIABLE : MSG_BROADCAST, msgid_SayText, _, iPlayer);
		write_byte(i);
		write_string(sMessage);
		message_end();
		
		team_Info(i, iPlayer, team_Names[sTeam]);
	}
}

team_Info(receiver, sender, sTeam[])
{
	static msgid_TeamInfo;
	if ( !msgid_TeamInfo ) msgid_TeamInfo = get_user_msgid("TeamInfo");
	
	message_begin(sender ? MSG_ONE_UNRELIABLE : MSG_BROADCAST, msgid_TeamInfo, _, sender);
	write_byte(receiver);
	write_string(sTeam);
	message_end();
}

get_Player()
{
	for ( new iPlayer = 1; iPlayer <= get_maxplayers(); iPlayer++ )
	{
		return iPlayer;
	}
	
	return 0;
}

